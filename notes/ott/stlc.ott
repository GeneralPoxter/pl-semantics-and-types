% This file includes the specification of the core grammar, operational semantics
% and typing rules 
%
% It also includes typesetting directives that control how the language is presented
% in the lecture notes.

%% STLC language

indexvar index, n ::= {{ coq nat }} 

metavar x, y, z, f, g ::=
  {{ com variables }}
  {{ lex alphanum }}

grammar

nat , j, k :: 'k_' ::= 
{{ com natural number constants }}
  | 0               ::   :: Zero
  | 1               ::   :: One
  | 2               ::   :: Two
  | 3               ::   :: Three
  | 4               ::   :: Four  
  | k1 + k2         ::   :: Plus
  | ( k )           :: S :: Paren

vs :: 'vs_' ::= 
{{ com sets of variables }}
  | { x }           ::   :: Single
  | emptyset        ::   :: Empty
  | vs1 U vs2       ::   :: Union
  | vs1 - vs2       ::   :: Minus
  | vars            ::   :: Total_set
    {{ tex \mathcal{V} }}
  | fv e            :: M :: FV 
  | ( vs )          :: S :: Paren

xi {{ tex \xi }} :: 'ren_' ::= 
{{ com renaming: map all variables in scope to new names }}
  | y / x           ::   :: Single
  | null            ::   :: Empty
  | xi1 , xi2       ::   :: Append
  | ( xi )          :: S :: Paren

sigma {{ tex \sigma }} , rho {{ tex \rho }} :: 'sub_' ::= 
{{ com substitution and environments: map all variables in scope to tersm }}
  | e / x           ::   :: Single
  | null            ::   :: Empty
  | sigma1 , sigma2 ::   :: Append
  | ( sigma )       :: S :: Paren

G {{ tex \Gamma }}, D {{tex \Delta}} :: 'ctx_' ::= 
{{ com typing contexts: map all variables in scope to types }}
  | x : tau         ::    :: Single {{ tex [[x]]\! :\![[tau]] }}
  |                 ::    :: Nil
    {{ tex \emptyset }}
  | G1 , G2         ::    :: Append 
  | ( G )           :: S  :: Paren

ty, tau {{ tex \tau }} :: 'ty_' ::= 
{{ com types }}
  | Nat             ::   :: Nat     {{ com base type: natural numbers }}
  | tau1 -> tau2    ::   :: Arrow   {{ com function types }}
  | G x             :: M :: Ctx     {{ com lookup from typing context }}
  | ( tau )         :: S :: Paren


tm, e :: 'tm_' ::= 
{{ com terms }}
  | k                ::   :: Const     {{ com natural number constant }}
  | x                ::   :: Var       {{ com variable }}
  | xi x             :: M :: Renaming  {{ com renamed variable }}

  | let x = e1 in e2 ::   :: Let

  | \ x . e          ::   :: Abs       {{ com function definition }}
    {{ tex \lambda [[x]]. [[e]] }}

  | \ x : tau . e    :: S :: AAbs {{ com function definition (annotated with type) }}
    {{ tex \lambda [[x]]\!:\![[tau]]. [[e]] }}

  | e1 e2            ::   :: App        {{ com function application }}
    {{ tex [[e1]] \; [[e2]] }}   

  | e [ sigma ]      :: M :: SubstOp    {{ com substitution }}
 
  | e < xi >         :: M :: RenOp      {{ com renaming }}

  | zero             ::   :: Zero
   
  | succ e           ::   :: Succ

  | natrec e e0 e1   ::   :: Natrec     {{ com recursor for natural numbers }}

  | ( e : tau )      ::   :: Ann        {{ com type annotation }}

  | ( e )            :: S :: Paren      {{ com parenthesis }}

v :: 'v_' ::= 
{{ com values }}

  | \ x . e         ::   :: Lam

  | k               ::   :: Const

  | zero            ::   :: Zero

  | succ v          ::   :: Succ

  | v [ sigma ]     :: M :: SubstOp

  | v < xi >        :: M :: RenOp

  | v , rho         :: M :: Closure

  | ( v )           :: S :: Paren



subrules
  v <:: e

parsing
ty_Arrow right ty_Arrow

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

grammar


terminals :: 'terminals_' ::=
  | min               ::   :: min           {{ tex \mathsf{min} }}
  | ok                ::   :: ok            {{ tex \mathsf{ok} }}
  | fv                ::   :: fv            {{ tex \mathsf{fv}\! }}
  | dom               ::   :: dom           {{ tex \mathsf{dom} }}
  | ==                ::   :: definitional  {{ tex \equiv }}
  | all               ::   :: forall        {{ tex \forall }}
  | elem              ::   :: elem          {{ tex \in }}
  | notin             ::   :: notin         {{ tex \not\in }}
  | <=                ::   :: check         {{ tex \Leftarrow }}
  | =>                ::   :: infer         {{ tex \Rightarrow }}
  | =>*               ::   :: minfer        {{ tex \Rightarrow^{\ast} }}
  | ->                ::   :: arrow         {{ tex \to }}
  | /\                ::   :: ilam          {{ tex \mathrm{\Lambda} }}
  | []                ::   :: box           {{ tex \Box }}
  | |-                ::   :: entails       {{ tex \vdash }}
  | |=                ::   :: proves        {{ tex \vDash }}
  | /=                ::   :: neq           {{ tex \neq }}
  | |>                ::   :: cast          {{ tex \triangleright }}
  | _                 ::   :: blank         {{ tex \_ }}
  | ~>                ::   :: step          {{ tex \leadsto }}
  | ~>*               ::   :: multistep     {{ tex \leadsto^{\ast} }}
  | empty             ::   :: empty         {{ tex \varnothing }}
  | hole              ::   :: hole          {{ tex \circ }}
  | ~                 ::   :: twiddle       {{ tex \sim }}
  | ~~                ::   :: compatible    {{ tex \asymp }}
  | '|'               ::   :: bar           {{ tex | }}
  | o                 ::   :: bullet        {{ tex \bullet }}
  | fst               ::   :: fst
  | snd               ::   :: snd
  | ==>               ::   :: impl          {{ tex \implies }}
  | U                 ::   :: cup           {{ tex \cup }}
  | emptyset          ::   :: emptyset      {{ tex \emptyset }}
  | <                 ::   :: langle        {{ tex \langle }}
  | >                 ::   :: rangle        {{ tex \rangle }}
  | <->               ::   :: iso           {{ tex \leftrightarrow }}
  | <=>               ::   :: lrarrow       {{ tex \Leftrightarrow }}

formula :: 'formula_' ::=
  | judgement                ::   :: judgement
  | formula1 .. formulan     ::   :: dots
  | x : tau elem G           ::   :: inG

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
JTyping :: '' ::=

defn

G |- e : tau   ::   :: typing :: 't_'
{{ com Typing }}
by

------------ :: const
G |- k : Nat

x : tau elem G
----------- :: var
G |- x : tau

G |- e1 : tau1
G , x : tau1 |- e2 : tau2
----------------------------- :: let
G |- let x = e1 in e2 : tau2


---------------------- :: zero
G |- zero : Nat


G |- e : Nat 
---------------------- :: succ
G |- succ e : Nat

G |- e : Nat 
G |- e0 : tau
G , x : Nat |- e1 : tau -> tau
------------------------------- :: nrec
G |- natrec e e0 e1 : tau

G, x:tau1 |- e : tau2
------------------------  ::  abs
G |- \x.e : tau1 -> tau2


G |- e1 : tau1 -> tau2
G |- e2 : tau1
--------------------------- ::  app
G |- e1 e2 : tau2



defns
JSmall :: '' ::=

defn
e ~> e' ::   :: step :: 'small_'
{{ com small-step operational semantics }}
by

----------------------------------  :: letv
let x = v in e ~> e [v/x]

e1 ~> e1'
------------------------------------  :: let_cong
let x = e1 in e2 ~> let x = e1' in e2

----------------------------------  :: beta
(\x. e) v ~> e [ v / x]


e1 ~> e1'
------------------------  :: app_cong1
e1 e2 ~> e1' e2

e2 ~> e2'
------------------------  :: arg_cong2
v e2 ~> v e2

e ~> e'
------------------------  :: succ_cong
succ e ~> succ e'


-------------------------- :: nrec_zero
natrec zero e1 e2 ~> e1

----------------------------------------------- :: nrec_succ
natrec (succ v) e1 e2 ~> (e2[v/x]) (natrec v e1 e2)

e ~> e'
--------------------------------- :: nrec_cong
natrec e e1 e2 ~> natrec e' e1 e2

defn
e ~>* e' ::  :: multi :: ''
{{ com multi-step evaluation }}
by

------------------- :: refl
e ~>* e

e0 ~> e1
e1 ~>* e2
------------------- :: step
e0 ~>* e2


defn
e ~> k e' ::  :: multi :: ''
{{ com counted multi-step evaluation }}
{{ tex [[e]] [[~>]]^{[[k]]} [[e']] }}

by

------------------- :: refl
e ~>0 e

e0 ~> e1
e1 ~>k e2
------------------- :: step
e0 ~>1+k e2



defns
JBig :: 'big_' ::=

defn
e => v
{{ com big-step semantics }}


-------- :: val
v => v

e1 => v1
e2 [ v1 / x ] => v2
-----------------------   :: let
let x = e1 in e2 => v2


e1 => \x.e1'
e2 => v1
e1' [ v1 / x] => v2
--------------------  :: app
e1 e2 => v2

e => k
--------------------- :: succ
succ e => succ k

e => zero
e1 => v
------------------------- :: nrec_zero
nrec e e1 e2 => v

e => succ k
e1 [k .: null] (nrec k e1 e2) => v2
------------------------------------- :: nrec_succ
nrec e e1 e2 => v2




defns
JBigEnv :: 'big_env_' ::=

defn
rho |- e => v
{{ com big-step semantics }}


---------------------- :: var
rho |- x => x [rho]


-------- :: val
v => v

rho |- e1 => v1
[v1 / x] rho |- e2 => v2
-----------------------   :: let
let x = e1 in e2 => v2


e1 => \x.e1'
e2 => v1
e1' [ v1 / x] => v2
--------------------  :: app
e1 e2 => v2

e => v
--------------------- :: succ
succ e => succ v


e => zero
e1 => v
------------------------- :: nrec_zero
nrec e e1 e2 => v

e => succ v1
e1 [v .: null] (nrec v1 e1 e2) => v2
------------------------------------- :: nrec_succ
nrec e e1 e2 => v2
