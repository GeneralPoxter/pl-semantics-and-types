% This file includes the specification of the core grammar, operational semantics
% and typing rules 
%
% It also includes typesetting directives that control how the language is presented
% in the lecture notes.

%% STLC language

indexvar index, n ::= {{ coq nat }} 

metavar x, y, z, f, g ::=
  {{ com variables }}
  {{ lex alphanum }}

grammar

nat , j, k :: 'k_' ::= 
{{ com natural number constants }}
  | 0               ::   :: Zero
  | 1               ::   :: One
  | 2               ::   :: Two
  | 3               ::   :: Three
  | 4               ::   :: Four  
  | 5               ::   :: Five
  | k1 + k2         ::   :: Plus
  | k1 - k2         ::   :: Minus
  | ( k )           :: S :: Paren

vs :: 'vs_' ::= 
{{ com sets of variables }}
  | { x }           ::   :: Single
  | emptyset        ::   :: Empty
  | vs1 U vs2       ::   :: Union
  | vs1 - vs2       ::   :: Minus
  | vars            ::   :: Total_set
    {{ tex \mathcal{V} }}
  | fv e            :: M :: FV 
  | dom xi          :: M :: Dom_ren
  | rng xi          :: M :: Rng_ren
  | dom sigma       :: M :: Dom_sub
  | dom G           :: M :: Dom_ctx
  | ( vs )          :: S :: Paren

xi {{ tex \xi }} :: 'ren_' ::= 
{{ com renaming: map all variables in scope to new names }}
  | y / x           ::   :: Single
  | null            ::   :: Empty
  | xi1 , xi2       ::   :: Append
  | ( xi )          :: S :: Paren

sigma {{ tex \sigma }} , rho {{ tex \rho }} :: 'sub_' ::= 
{{ com substitution and environments: map all variables in scope to tersm }}
  | e / x           ::   :: Single
  | null            ::   :: Empty
  | sigma1 , sigma2 ::   :: Append
  | ( sigma )       :: S :: Paren

G {{ tex \Gamma }} , D {{tex \Delta}} :: 'ctx_' ::= 
{{ com typing contexts: map all variables in scope to types }}
  | x : tau         ::    :: Single {{ tex [[x]]\! :\![[tau]] }}
  |                 ::    :: Nil
    {{ tex \emptyset }}
  | G1 , G2         ::    :: Append 
  | ( G )           :: S  :: Paren

tau {{ tex \tau }} :: 'ty_' ::= 
{{ com types }}
  | Nat             ::   :: Nat     {{ com base type: natural numbers }}
  | tau1 -> tau2    ::   :: Arrow   {{ com function types }}
  | G x             :: M :: Ctx     {{ com lookup from typing context }}
  | ( tau )         :: S :: Paren


e :: 'tm_' ::= 
{{ com terms }}
  | k                ::   :: Lit     {{ com natural number constant }}
  | x                ::   :: Var       {{ com variable }}
  | xi x             :: M :: Renaming  {{ com renamed variable }}
  | sigma x          :: M :: VarSub    {{ com lookup from substitution }}

  | let x = e1 in e2 ::   :: Let

  | \ x . e          ::   :: Abs       {{ com function definition }}
    {{ tex \lambda [[x]]. [[e]] }}

  | \ x : tau . e    :: S :: AAbs {{ com function definition (annotated with type) }}
    {{ tex \lambda [[x]]\!:\![[tau]]. [[e]] }}

  | e1 e2            ::   :: App        {{ com function application }}
    {{ tex [[e1]] \; [[e2]] }}   

  | e [ sigma ]      :: M :: SubstOp    {{ com substitution }}
 
  | e < xi >         :: M :: RenOp      {{ com renaming }}

  | e , rho          :: M :: Closure    


  | succ e           ::   :: Succ

  | natrec e of { zero => e0 ; succ x => e1 }  ::   :: Natrec 
      {{ com recursor for natural numbers }}

  | ( e : tau )      ::   :: Ann        {{ com type annotation }}

  | ( e )            :: S :: Paren      {{ com parenthesis }}

v :: 'v_' ::= 
{{ com values }}

  | \ x . e         ::   :: Lam

  | k               ::   :: Lit

  | succ v          ::   :: Succ

  | v [ sigma ]     :: M :: SubstOp

  | v < xi >        :: M :: RenOp

  | rho x           :: M :: LookupRho

  | v , rho         :: M :: Closure

  | ( v )           :: S :: Paren



subrules
  v <:: e

parsing
ty_Arrow right ty_Arrow

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

grammar


terminals :: 'terminals_' ::=
  | min               ::   :: min           {{ tex \mathsf{min} }}
  | ok                ::   :: ok            {{ tex \mathsf{ok} }}
  | fv                ::   :: fv            {{ tex \mathsf{fv}\! }}
  | dom               ::   :: dom           {{ tex \mathsf{dom} }}
  | rng               ::   :: rng           {{ tex \mathsf{rng} }}
  | ==                ::   :: equiv         {{ tex \equiv }}
  | all               ::   :: forall        {{ tex \forall }}
  | elem              ::   :: elem          {{ tex \in }}
  | notin             ::   :: notin         {{ tex \not\in }}
  | <=                ::   :: check         {{ tex \Leftarrow }}
  | =>                ::   :: infer         {{ tex \Rightarrow }}
  | =>*               ::   :: minfer        {{ tex \Rightarrow^{\ast} }}
  | ->                ::   :: arrow         {{ tex \to }}
  | /\                ::   :: ilam          {{ tex \mathrm{\Lambda} }}
  | []                ::   :: box           {{ tex \Box }}
  | |-                ::   :: entails       {{ tex \vdash }}
  | |=                ::   :: proves        {{ tex \vDash }}
  | /=                ::   :: neq           {{ tex \neq }}
  | |>                ::   :: cast          {{ tex \triangleright }}
  | _                 ::   :: blank         {{ tex \_ }}
  | ~>                ::   :: step          {{ tex \leadsto }}
  | ~>*               ::   :: multistep     {{ tex \leadsto^{\ast} }}
  | empty             ::   :: empty         {{ tex \varnothing }}
  | hole              ::   :: hole          {{ tex \circ }}
  | ~                 ::   :: twiddle       {{ tex \sim }}
  | ~~                ::   :: compatible    {{ tex \asymp }}
  | '|'               ::   :: bar           {{ tex | }}
  | o                 ::   :: bullet        {{ tex \bullet }}
  | fst               ::   :: fst
  | snd               ::   :: snd
  | ==>               ::   :: impl          {{ tex \implies }}
  | U                 ::   :: cup           {{ tex \cup }}
  | emptyset          ::   :: emptyset      {{ tex \emptyset }}
  | <                 ::   :: langle        {{ tex \langle }}
  | >                 ::   :: rangle        {{ tex \rangle }}
  | <->               ::   :: iso           {{ tex \leftrightarrow }}
  | <=>               ::   :: lrarrow       {{ tex \Leftrightarrow }}

formula :: 'formula_' ::=
  | judgement                ::   :: judgement
  | formula1 .. formulan     ::   :: dots
  | x : tau elem G           ::   :: inG

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
JTyping :: '' ::=

defn

G |- e : tau   ::   :: typing :: 't_'
{{ com Typing }}
by

------------ :: lit
G |- k : Nat

x : tau elem G
----------- :: var
G |- x : tau

G |- e1 : tau1
G , x : tau1 |- e2 : tau2
----------------------------- :: let
G |- let x = e1 in e2 : tau2

G |- e : Nat 
---------------------- :: succ
G |- succ e : Nat

G |- e : Nat 
G |- e0 : tau
G , x : Nat |- e1 : tau -> tau
------------------------------- :: nrec
G |- natrec e of { zero => e0 ; succ x => e1 } : tau

G, x:tau1 |- e : tau2
------------------------  ::  abs
G |- \x.e : tau1 -> tau2


G |- e1 : tau1 -> tau2
G |- e2 : tau1
--------------------------- ::  app
G |- e1 e2 : tau2



defns
JSmall :: '' ::=

defn
e ~> e' ::   :: step :: 's_'
{{ com small-step operational semantics }}
by

----------------------------------  :: letv
let x = v in e ~> e [v/x]

e1 ~> e1'
------------------------------------  :: let_cong
let x = e1 in e2 ~> let x = e1' in e2

----------------------------------  :: beta
(\x. e) v ~> e [ v / x]


e1 ~> e1'
------------------------  :: app_cong1
e1 e2 ~> e1' e2

e2 ~> e2'
------------------------  :: app_cong2
v e2 ~> v e2

e ~> e'
------------------------  :: succ_cong
succ e ~> succ e'


-------------------------- :: nrec_zero
natrec 0 of { zero => e1 ; succ x =>  e2 } ~> e1

----------------------------------------------- :: nrec_succ
natrec (1+k) of { zero => e1 ; succ x => e2 } ~> (e2[k/x]) (natrec v of {zero => e1 ; succ x => e2})

e ~> e'
--------------------------------- :: nrec_cong
natrec e of { zero => e1 ; succ x => e2 }  ~> natrec e' of { zero => e1; succ x => e2 }

defn
e ~>* e' ::  :: multi :: 'ms_'
{{ com multi-step evaluation }}
by

------------------- :: refl
e ~>* e

e0 ~> e1
e1 ~>* e2
------------------- :: step
e0 ~>* e2


defn
e ~ k >  e' ::  :: ms_k_ :: 'ms_k_'
{{ com counted multi-step evaluation }}
{{ tex [[e]] \leadsto^{[[k]]} [[e']] }}

by

------------------- :: refl
e ~0> e

e0 ~> e1
e1 ~k> e2
------------------- :: step
e0 ~1+k> e2



defns
JBig :: '' ::=

defn
e => v ::   :: big :: 'big_'
{{ com big-step semantics }}
by


-------- :: val
v => v

e1 => v1
e2 [ v1 / x ] => v2
-----------------------   :: let
let x = e1 in e2 => v2


e1 => \x.e1'
e2 => v1
e1' [ v1 / x] => v2
--------------------  :: app
e1 e2 => v2

e => k
--------------------- :: succ
succ e => succ k

e => 0
e1 => v
------------------------- :: nrec_zero
natrec e of {zero => e1 ; succ x => e2 }  => v

e => 1+k
%% (e1 [k / x]) (natrec k e1 e2) => v
--------------------------------------------- :: nrec_succ
natrec e of {zero=> e1 ; succ x => e2 } => v




defns
JBigEnv :: '' ::=

defn
rho |- e => v ::   :: big_eng :: 'big_env_' 
{{ com big-step semantics }}
by


---------------------- :: var
rho |- x => rho x


------------------ :: lit
rho |- k => k

------------------------- :: cons
rho |- \x.e => \x.e , rho


rho |- e1 => v1
v1/x,rho |- e2 => v2
-----------------------   :: let
rho |- let x = e1 in e2 => v2


rho |- e1 => \x.e1', rho'
rho |- e2 => v1
v1/x,rho' |- e1' => v2
--------------------  :: app
rho |- e1 e2 => v2

rho |- e => k
-------------------------- :: succ
rho |- succ e => succ k


rho |- e => 0
rho |- e1 => v
---------------------------------------------------- :: nrec_zero
rho |- natrec e of { zero=> e1 ; succ x => e2 } => v

rho |- e => 1+k
rho |- e1 [k/x] (natrec v1 of { zero => e1 ; succ x => e2}) => v2
------------------------------------------------------------------ :: nrec_succ
rho |- natrec e of { zero=> e1 ; succ x => e2 } => v2
